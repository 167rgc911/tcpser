bridge.c:  cfg->line_data.fd=ip_accept(cfg->line_data.sfd);
bridge.c:  if(cfg->line_data.fd > -1) {
bridge.c:    cfg->line_data.valid_conn=TRUE;
bridge.c:    cfg->rings=0;
bridge.c:    writePipe(cfg->data.mp[0][1],MSG_ACCEPTED);
bridge.c:  if(cfg->line_data.first_char==TRUE) {
bridge.c:    cfg->line_data.first_char=FALSE;
bridge.c:      cfg->line_data.is_telnet=TRUE;
bridge.c:  if(cfg->line_data.is_telnet == TRUE) {
bridge.c:            parse_nvt_command(cfg->line_data.fd,ch,data[i+2]);
bridge.c:            i+=parse_nvt_subcommand(cfg->line_data.fd, cfg->line_data.nvt_data,data + i,len);
bridge.c:    FD_SET(cfg->data.cp[1][0], &readfs); 
bridge.c:    max_fd=cfg->data.cp[1][0];
bridge.c:       && cfg->conn_type != MDM_CONN_NONE 
bridge.c:       && cfg->cmd_mode == FALSE 
bridge.c:       && cfg->line_data.fd > -1
bridge.c:       && cfg->line_data.valid_conn ==TRUE
bridge.c:      FD_SET(cfg->line_data.fd, &readfs); 
bridge.c:      max_fd=MAX(max_fd,cfg->line_data.fd);
bridge.c:      if (FD_ISSET(cfg->line_data.fd,&readfs)) {  // socket
bridge.c:        res = recv(cfg->line_data.fd,buf,sizeof(buf) - 1,0);
bridge.c:          writePipe(cfg->data.cp[0][1],MSG_DISCONNECT);
bridge.c:      if (FD_ISSET(cfg->data.cp[1][0],&readfs)) {  // pipe
bridge.c:        res = read(cfg->data.cp[1][0],buf,sizeof(buf) - 1);
bridge.c:          writePipe(cfg->data.wp[0][1],MSG_DTR_DOWN);
bridge.c:          writePipe(cfg->data.wp[0][1],MSG_DTR_UP);
bridge.c:  if( -1 == pipe(cfg->data.wp[0])) {
bridge.c:  if( -1 == pipe(cfg->data.cp[0])) {
bridge.c:  if( -1 == pipe(cfg->data.cp[1])) {
bridge.c:  strncpy(cfg->cur_line,cfg->config0,sizeof(cfg->cur_line));
bridge.c:  cfg->allow_transmit=FALSE;
bridge.c:  cfg->allow_transmit=TRUE;
bridge.c:  cfg->line_data.fd=-1;
bridge.c:  last_conn_type=cfg->conn_type;
bridge.c:    if(last_conn_type!= cfg->conn_type) {
bridge.c:      //writePipe(cfg->data.mp[0][1],MSG_NOTIFY);
bridge.c:      writePipe(cfg->data.cp[1][1],MSG_NOTIFY);
bridge.c:      if(cfg->conn_type == MDM_CONN_OUTGOING) {
bridge.c:        if(strlen(cfg->data.local_connect) > 0) {
bridge.c:          writeFile(cfg->data.local_connect,cfg->line_data.fd);
bridge.c:        if(strlen(cfg->data.remote_connect) > 0) {
bridge.c:          writeFile(cfg->data.remote_connect,cfg->line_data.fd);
bridge.c:      } else if(cfg->conn_type == MDM_CONN_INCOMING) {
bridge.c:        if(strlen(cfg->data.local_answer) > 0) {
bridge.c:          writeFile(cfg->data.local_answer,cfg->line_data.fd);
bridge.c:        if(strlen(cfg->data.remote_answer) > 0) {
bridge.c:          writeFile(cfg->data.remote_answer,cfg->line_data.fd);
bridge.c:      last_conn_type=cfg->conn_type;
bridge.c:    LOG(LOG_ALL,"Command Mode=%d, Connection status=%d",cfg->cmd_mode,cfg->conn_type);
bridge.c:    max_fd=MAX(cfg->data.mp[1][0],cfg->dce_data.fd);
bridge.c:    max_fd=MAX(max_fd,cfg->data.wp[0][0]);
bridge.c:    max_fd=MAX(max_fd,cfg->data.cp[0][0]);
bridge.c:    FD_SET(cfg->data.mp[1][0], &readfs); 
bridge.c:    FD_SET(cfg->dce_data.fd, &readfs); 
bridge.c:    FD_SET(cfg->data.wp[0][0], &readfs); 
bridge.c:    FD_SET(cfg->data.cp[0][0], &readfs); 
bridge.c:    if(cfg->cmd_mode == FALSE) {
bridge.c:      if(cfg->pre_break_delay == FALSE || cfg->break_len == 3) {
bridge.c:        timer.tv_usec=cfg->s[12] * 20000;
bridge.c:      } else if(cfg->pre_break_delay == TRUE && cfg->break_len > 0) {
bridge.c:      } else if (cfg->s[30] != 0) {
bridge.c:        timer.tv_sec=cfg->s[30] * 10;
bridge.c:    } else if(cfg->cmd_mode == TRUE && cfg->conn_type== MDM_CONN_NONE && cfg->line_data.valid_conn ==TRUE) {
bridge.c:      if(cfg->cmd_mode == TRUE && cfg->conn_type == MDM_CONN_NONE && cfg->line_data.valid_conn == TRUE) {
bridge.c:        if(cfg->s[0] == 0 && cfg->rings==10) {
bridge.c:          if(strlen(cfg->data.no_answer) == 0) {
bridge.c:            writeFile(cfg->data.no_answer,cfg->line_data.fd);
bridge.c:    if (FD_ISSET(cfg->dce_data.fd,&readfs)) {  // serial port
bridge.c:      res = read(cfg->dce_data.fd,buf,sizeof(buf) -1);
bridge.c:    if (FD_ISSET(cfg->data.wp[0][0],&readfs)) {  // control pipe
bridge.c:      res = read(cfg->data.wp[0][0],buf,sizeof(buf) -1);
bridge.c:    if (FD_ISSET(cfg->data.cp[0][0],&readfs)) {  // ip thread pipe
bridge.c:      res = read(cfg->data.cp[0][0],buf,sizeof(buf) -1);
bridge.c:    if (FD_ISSET(cfg->data.mp[1][0],&readfs)) {  // parent pipe
bridge.c:      res = read(cfg->data.mp[1][0],buf,sizeof(buf) -1);
dce.c:  cfg->dce_data.fd=ser_init_conn(cfg->dce_data.tty,cfg->dte_speed);
dce.c:  return cfg->dce_data.fd;
dce.c:  rc=ser_set_flow_control(cfg->dce_data.fd,status);
dce.c:  rc = ser_set_control_lines(cfg->dce_data.fd,status);
dce.c:  status = ser_get_control_lines(cfg->dce_data.fd);
dce.c:  return ser_write(cfg->dce_data.fd,data,len);
dce.c:  return ser_read(cfg->dce_data.fd,data,len);
line.c:  cfg->line_data.fd=-1;
line.c:  return ip_write(cfg->line_data.fd,data,len);
line.c:  unsigned char* addy=cfg->dialno;
line.c:  cfg->line_data.fd=ip_connect(addy);
line.c:  if(cfg->line_data.fd > -1) {
line.c:    cfg->line_data.valid_conn = TRUE;
line.c:    cfg->line_data.valid_conn = FALSE;
line.c:  cfg->line_data.is_telnet=FALSE;
line.c:  cfg->line_data.first_char=TRUE;
line.c:  if(cfg->line_data.valid_conn == TRUE) {
line.c:    ip_disconnect(cfg->line_data.fd);
line.c:    cfg->line_data.valid_conn=FALSE;
modem_core.c:  cfg->send_responses=TRUE;
modem_core.c:  cfg->connect_response=0;
modem_core.c:  cfg->response_code_level=4;
modem_core.c:  cfg->text_responses=TRUE;
modem_core.c:  cfg->echo=TRUE;
modem_core.c:  cfg->cmd_mode=TRUE;
modem_core.c:  cfg->conn_type=MDM_CONN_NONE;
modem_core.c:  cfg->off_hook=FALSE;
modem_core.c:  cfg->line_ringing=FALSE;
modem_core.c:  cfg->cur_line_idx=0;
modem_core.c:    cfg->s[i]=0;
modem_core.c:  cfg->s[2]=43;
modem_core.c:  cfg->s[3]=13;
modem_core.c:  cfg->s[4]=10;
modem_core.c:  cfg->s[5]=8;
modem_core.c:  cfg->s[6]=2;
modem_core.c:  cfg->s[7]=50;
modem_core.c:  cfg->s[8]=2;
modem_core.c:  cfg->s[9]=6;
modem_core.c:  cfg->s[10]=14;
modem_core.c:  cfg->s[11]=95;
modem_core.c:  cfg->s[12]=50;
modem_core.c:  cfg->crlf[0]=cfg->s[3];
modem_core.c:  cfg->crlf[1]=cfg->s[4];
modem_core.c:  cfg->crlf[2]=0;
modem_core.c:  cfg->last_char='\0';
modem_core.c:  cfg->dial_type=0;
modem_core.c:  cfg->last_dial_type=0;
modem_core.c:  cfg->disconnect_delay=0;
modem_core.c:  cfg->pre_break_delay=FALSE;
modem_core.c:  cfg->break_len=0;
modem_core.c:  cfg->memory_dial=FALSE;
modem_core.c:  cfg->dsr_active=FALSE;
modem_core.c:  cfg->dsr_on=TRUE;
modem_core.c:  cfg->dcd_on=FALSE;
modem_core.c:  cfg->found_a=FALSE;
modem_core.c:  cfg->cmd_started=FALSE;
modem_core.c:  cfg->allow_transmit=TRUE;
modem_core.c:  cfg->invert_dsr=FALSE;
modem_core.c:  cfg->invert_dcd=FALSE;
modem_core.c:  cfg->config0[0]='\0';
modem_core.c:  cfg->config1[0]='\0';
modem_core.c:  if(cfg->dsr_on == TRUE)
modem_core.c:    return (cfg->invert_dsr == TRUE?MDM_CL_DSR_LOW:MDM_CL_DSR_HIGH);
modem_core.c:  if((up == TRUE && cfg->invert_dsr == FALSE) 
modem_core.c:     || (up == FALSE && cfg->invert_dsr==TRUE)
modem_core.c:  if(cfg->dcd_on == TRUE)
modem_core.c:    return (cfg->invert_dcd == TRUE?MDM_CL_DCD_LOW:MDM_CL_DCD_HIGH);
modem_core.c:  if((up == TRUE && cfg->invert_dcd == FALSE) 
modem_core.c:     || (up == FALSE && cfg->invert_dcd==TRUE)
modem_core.c:  int up=(cfg->conn_type == MDM_CONN_NONE?FALSE:TRUE);
modem_core.c:  if(cfg->allow_transmit == TRUE) {
modem_core.c:  if(cfg->send_responses==TRUE) {
modem_core.c:    mdm_write(cfg,cfg->crlf,2);
modem_core.c:    if(cfg->text_responses==TRUE) {
modem_core.c:    mdm_write(cfg,cfg->crlf,2);
modem_core.c:  cfg->off_hook=TRUE;
modem_core.c:  cfg->cmd_mode=FALSE;
modem_core.c:  if(cfg->line_ringing == TRUE) {
modem_core.c:    cfg->conn_type=MDM_CONN_INCOMING;
modem_core.c:    switch(cfg->connect_response) {
modem_core.c:        speed=cfg->dte_speed;
modem_core.c:        speed=cfg->dce_speed;
modem_core.c:    mdm_send_response(get_connect_response(speed,cfg->response_code_level),cfg);
modem_core.c:  if(cfg->conn_type == MDM_CONN_NONE) {
modem_core.c:      cfg->conn_type=MDM_CONN_OUTGOING;
modem_core.c:      switch(cfg->connect_response) {
modem_core.c:          speed=cfg->dte_speed;
modem_core.c:          speed=cfg->dce_speed;
modem_core.c:      mdm_send_response(get_connect_response(speed,cfg->response_code_level),cfg);
modem_core.c:      cfg->conn_type=MDM_CONN_OUTGOING;   // so disconnect will print NO CARRIER
modem_core.c:  type=cfg->conn_type;
modem_core.c:  cfg->conn_type=MDM_CONN_NONE;
modem_core.c:  cfg->off_hook=FALSE;
modem_core.c:  cfg->cmd_mode=TRUE;
modem_core.c:  cfg->break_len=0;
modem_core.c:  cfg->line_ringing = FALSE;
modem_core.c:  cfg->pre_break_delay=FALSE;
modem_core.c:    usleep(cfg->disconnect_delay * 1000);
modem_core.c:  cfg->rings=0;
modem_core.c:  unsigned char* command=cfg->cur_line;
modem_core.c:        if(cfg->cmd_mode == TRUE)
modem_core.c:          //cfg->connect_1200=num;
modem_core.c:          strncpy(cfg->dialno,command+start,end-start);
modem_core.c:          cfg->dialno[end-start]='\0';
modem_core.c:          cfg->dial_type=(unsigned char)num;
modem_core.c:          cfg->last_dial_type=(unsigned char)num;
modem_core.c:          strncpy(cfg->last_dialno,command+start,end-start);
modem_core.c:          cfg->last_dialno[end-start]='\0';
modem_core.c:          cfg->memory_dial=FALSE;
modem_core.c:          strncpy(cfg->dialno,cfg->last_dialno,strlen(cfg->last_dialno));
modem_core.c:          cfg->dial_type=cfg->dial_type;
modem_core.c:          cfg->memory_dial=TRUE;
modem_core.c:          mdm_write(cfg,cfg->crlf,2);
modem_core.c:          mdm_write(cfg,cfg->dialno,strlen(cfg->dialno));
modem_core.c:          cfg->dialno[0]=0;
modem_core.c:          cfg->last_dialno[0]=0;
modem_core.c:          cfg->dial_type=0;
modem_core.c:          cfg->last_dial_type=0;
modem_core.c:        if(strlen(cfg->dialno) > 0)
modem_core.c:          cfg->echo=FALSE;
modem_core.c:          cfg->echo=TRUE;
modem_core.c:          //cfg->volume=num;
modem_core.c:          //cfg->speaker_setting=num;
modem_core.c:          //cfg->auto_mode=num;
modem_core.c:        //cfg->default_dial_type=MDM_DT_PULSE;
modem_core.c:          cfg->send_responses=FALSE;
modem_core.c:          cfg->send_responses=TRUE;
modem_core.c:          cfg->send_responses=TRUE;
modem_core.c:          cfg->s[num]=atoi(tmp);
modem_core.c:              cfg->crlf[0]=cfg->s[3];
modem_core.c:              cfg->crlf[1]=cfg->s[4];
modem_core.c:        //cfg->default_dial_type=MDM_DT_TONE;
modem_core.c:          cfg->text_responses=FALSE;
modem_core.c:          cfg->text_responses=TRUE;
modem_core.c:            cfg->connect_response=num;
modem_core.c:            cfg->response_code_level=num;
modem_core.c:          //cfg->long_disconnect=num;
modem_core.c:            cfg->dcd_on=TRUE;
modem_core.c:            cfg->dcd_on=FALSE;
modem_core.c:  cfg->cur_line_idx=0;
modem_core.c:  if(cfg->echo == TRUE)
modem_core.c:  if(cfg->cmd_started == TRUE) {
modem_core.c:    if(ch == (unsigned char)(cfg->s[5])) {
modem_core.c:      if(cfg->cur_line_idx == 0 && cfg->echo == TRUE) {
modem_core.c:        cfg->cur_line_idx--;
modem_core.c:    } else if(ch == (unsigned char)(cfg->s[3])) {
modem_core.c:      cfg->cur_line[cfg->cur_line_idx]=0;
modem_core.c:      cfg->cur_line_idx=0;
modem_core.c:      cfg->cmd_started=FALSE;
modem_core.c:      cfg->cur_line[cfg->cur_line_idx++ % sizeof(cfg->cur_line)]=ch;
modem_core.c:  } else if(cfg->found_a == TRUE) {
modem_core.c:    cfg->found_a=FALSE;
modem_core.c:      cfg->cmd_started=TRUE;
modem_core.c:    cfg->found_a=TRUE;
modem_core.c:  cfg->break_len=0;
modem_core.c:  cfg->pre_break_delay=FALSE;
modem_core.c:  if(cfg->cmd_mode==TRUE) {
modem_core.c:    if(cfg->pre_break_delay == TRUE) {
modem_core.c:        if(data[i] == (unsigned char)cfg->s[2]) {
modem_core.c:          cfg->break_len++;
modem_core.c:          if(cfg->break_len > 3) {  // more than 3, considered invalid
modem_core.c:            cfg->pre_break_delay=FALSE;
modem_core.c:            cfg->break_len=0;
modem_core.c:  if(cfg->pre_break_delay == TRUE && cfg->break_len == 3) {
modem_core.c:    cfg->cmd_mode=TRUE;
modem_core.c:  } else if(cfg->pre_break_delay == FALSE) {
modem_core.c:    cfg->pre_break_delay=TRUE;
modem_core.c:  } else if(cfg->pre_break_delay == TRUE 
modem_core.c:            && cfg->break_len > 0
modem_core.c:  } else if(cfg->s[30] != 0) {
modem_core.c:  cfg->line_ringing = TRUE;
modem_core.c:  cfg->rings++;
modem_core.c:  LOG(LOG_ALL,"Sent #%d ring",cfg->rings);
modem_core.c:  if(cfg->cmd_mode == FALSE || (cfg->s[0] != 0 &&cfg->rings>=cfg->s[0])) {
shared.c:  cfg->data.local_connect[0]=0;
shared.c:  cfg->data.remote_connect[0]=0;
shared.c:  cfg->data.local_answer[0]=0;
shared.c:  cfg->data.remote_answer[0]=0;
shared.c:  cfg->data.no_answer[0]=0;
shared.c:  cfg->data.inactive[0]=0;
tcpser.c:      LOG(LOG_FATAL,"Could not open serial port %s",cfg->dce_data.tty);
